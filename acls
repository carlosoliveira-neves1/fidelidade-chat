[1mdiff --git a/backend/src/db.py b/backend/src/db.py[m
[1mindex 44cec6a..a5f04c6 100644[m
[1m--- a/backend/src/db.py[m
[1m+++ b/backend/src/db.py[m
[36m@@ -1,67 +1,33 @@[m
[31m-# src/db.py  (substitua tudo por este conte√∫do)[m
[31m-[m
 import os[m
 from sqlalchemy import create_engine[m
 from sqlalchemy.orm import sessionmaker, scoped_session, declarative_base[m
 [m
[31m-[m
[31m-def _build_url_from_db_parts():[m
[31m-    user = os.getenv("DB_USER")[m
[31m-    pwd  = os.getenv("DB_PASSWORD")[m
[31m-    host = os.getenv("DB_HOST")[m
[31m-    port = os.getenv("DB_PORT", "5432")[m
[31m-    name = os.getenv("DB_NAME")[m
[31m-[m
[31m-    if all([user, pwd, host, name]):[m
[31m-        # Usa driver psycopg2 expl√≠cito[m
[31m-        return f"postgresql+psycopg2://{user}:{pwd}@{host}:{port}/{name}"[m
[31m-    return None[m
[31m-[m
[31m-[m
[31m-def _resolve_database_url():[m
[31m-    # 1) Se veio pronta, usa.[m
[31m-    url = os.getenv("DATABASE_URL")[m
[31m-    if url:[m
[31m-        return url[m
[31m-[m
[31m-    # 2) Caso contr√°rio, monta a partir de DB_*[m
[31m-    url = _build_url_from_db_parts()[m
[31m-    if url:[m
[31m-        return url[m
[31m-[m
[31m-    # 3) Fallback local (dev)[m
[31m-    return "sqlite:///db.sqlite3"[m
[31m-[m
[31m-[m
[31m-def _resolve_connect_args(url: str):[m
[31m-    """[m
[31m-    Define 'search_path' para o schema correto no Postgres e SSL.[m
[31m-    Suporta DATABASE_SCHEMA (legado) e DB_SCHEMA (recomendado).[m
[31m-    """[m
[31m-    schema = os.getenv("DB_SCHEMA") or os.getenv("DATABASE_SCHEMA") or "public"[m
[31m-[m
[31m-    # Apenas para Postgres (psycopg2)[m
[31m-    if url.startswith("postgresql"):[m
[31m-        return {[m
[31m-            "options": f"-csearch_path={schema}",[m
[31m-            # DBaaS costuma exigir SSL:[m
[31m-            "sslmode": os.getenv("DB_SSLMODE", "require"),[m
[31m-        }[m
[31m-    return {}[m
[31m-[m
[31m-[m
[31m-DATABASE_URL = _resolve_database_url()[m
[31m-CONNECT_ARGS  = _resolve_connect_args(DATABASE_URL)[m
[32m+[m[32m# 1) L√™ vari√°veis simples[m
[32m+[m[32mDB_HOST = os.getenv("DB_HOST")[m
[32m+[m[32mDB_PORT = os.getenv("DB_PORT", "5432")[m
[32m+[m[32mDB_NAME = os.getenv("DB_NAME")[m
[32m+[m[32mDB_USER = os.getenv("DB_USER")[m
[32m+[m[32mDB_PASSWORD = os.getenv("DB_PASSWORD")[m
[32m+[m[32mDATABASE_SCHEMA = os.getenv("DATABASE_SCHEMA")[m
[32m+[m
[32m+[m[32m# 2) Monta a URL do Postgres (Render)[m
[32m+[m[32mDATABASE_URL = os.getenv("DATABASE_URL")[m
[32m+[m[32mif not DATABASE_URL and DB_HOST and DB_NAME and DB_USER and DB_PASSWORD:[m
[32m+[m[32m    DATABASE_URL = ([m
[32m+[m[32m        f"postgresql+psycopg2://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}"[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m[32m# 3) Fallback local (sqlite) se nada for definido[m
[32m+[m[32mconnect_args = {}[m
[32m+[m[32mif not DATABASE_URL:[m
[32m+[m[32m    DATABASE_URL = "sqlite:///db.sqlite3"[m
[32m+[m[32melse:[m
[32m+[m[32m    # Define search_path para o schema no Postgres[m
[32m+[m[32m    if DATABASE_SCHEMA:[m
[32m+[m[32m        connect_args = {"options": f"-csearch_path={DATABASE_SCHEMA}"}[m
 [m
 engine = create_engine([m
[31m-    DATABASE_URL,[m
[31m-    future=True,[m
[31m-    echo=False,[m
[31m-    connect_args=CONNECT_ARGS,[m
[31m-    pool_pre_ping=True,[m
[31m-)[m
[31m-[m
[31m-SessionLocal = scoped_session([m
[31m-    sessionmaker(bind=engine, autoflush=False, autocommit=False, future=True)[m
[32m+[m[32m    DATABASE_URL, future=True, echo=False, connect_args=connect_args[m
 )[m
[32m+[m[32mSessionLocal = scoped_session(sessionmaker(bind=engine, autoflush=False, autocommit=False, future=True))[m
 Base = declarative_base()[m
